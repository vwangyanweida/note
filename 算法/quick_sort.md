# 快排学习笔记

## 实现原理

- 给定一个数组，如果取一个key，如果可以使得移动这个key，使得key左边的数字小于等于key，而key右边的数字大于等于key，则这时key所在的位置就是排好序后key应该在的位置并且左边的子数组排好序后肯定都小于等于key，同理右边。这样递归调用后，就可以把数组排好。

- 就是做两件事，1.将key插到排好序的位置  2.保证key左边的值小于key，右边的值大于key

## 实现步骤

1. 在原数组上交换，且不用交换数据，仅仅赋值
	- 从头端取一个key，从尾端开始找大于key的值的索引是j **之所以要从另外一端开始，是因为不申请新的内存空间情况下，再原来的数组上移动数据，就像是c语言里交换两个变量一样，要把一个值放到一个临时变量里，这样才可以覆盖那个值，而key的值就相当于那个有临时变量的参数，需要先覆盖掉它**
	
	- 将找到的大于key的值覆盖到key上面，从头端开始往后找小于key的值索引为i，覆盖到j的位置，因为现在j已经有移动过了。 **有两个哨兵的原因是非别标识小于key的值和大于key的值往哪里插入，只有一个key(temp)所以要一次执行j和i因为执行两次i就会发现不能覆盖那个值，因为没有记录下它的值**
	
	- 递归调用key左边和右边的子数组 **注意排序传递的所有数组都是引用传递，所以需要传递排序的low和high索引的值**

## 代码实现

	def quick_srt(unsort_list, low, high):
    key = unsort_list[low]
    i = low
    j = high
    if i >= j:
        return
    while i < j:
        while i < j and unsort_list[j] >= key:
            j -= 1
        unsort_list[i] = unsort_list[j]
        while i <j and unsort_list[i] <= key:
            i += 1
        unsort_list[j] = unsort_list[i]

    unsort_list[j] = key
    quick_srt(unsort_list, low, i - 1)
    quick_srt(unsort_list, i+1, high)

	a = [16, 33, 44, 53, 23, 5, 23, 55, 67]
	quick_srt(a, 0, len(a) - 1)
	print(a)

## 优化
快排对于小规模的数据集性能不是很好

1. 根据分区大小优化

	- 当数据集较小时，不必继续递归调用快排算法，当递归达到一定深度时，就改为堆排序来处理
	- 当分区的规模达到一定小时，便停止快速排序。也即快速排序算法的最终产物是一个“几乎”排序完成的有序数列。数列中有部分元素并没有排到最终的有序序列的位置上，但是这种元素并不多。然后对结果使用插入排序算法完成，因为插入算法对这种几乎完成的排序有着接近线性的复杂度。
	- 在递归调用子分区时，优先排序那个最小的分区，这个选择能够更加有效的利用存储空间从而整体加速算法执行。